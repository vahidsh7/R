---
type WeekdayIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6;

type GitHubActivityDay = {
  date: string;
  count: number;
  level: number;
  color?: string;
};

type GitHubActivityWeek = Array<GitHubActivityDay | undefined>;

type GitHubActivityMonthLabel = { weekIndex: number; label: string };

type GitHubActivityApiResponse = {
  contributions: Array<GitHubActivityDay>;
  total: Record<string, number> & { lastYear: number };
  error?: string;
};

function parseISO(date: string): Date {
  return new Date(date);
}

function isValid(date: Date): boolean {
  return !Number.isNaN(date.getTime());
}

function formatISO(date: Date): string {
  return date.toISOString().slice(0, 10);
}

function getDay(date: Date): WeekdayIndex {
  return date.getDay() as WeekdayIndex;
}

function getYear(date: Date): number {
  return date.getFullYear();
}

function getMonth(date: Date): number {
  return date.getMonth();
}

function subWeeks(date: Date, weeks: number): Date {
  const d = new Date(date);
  d.setDate(d.getDate() - weeks * 7);
  return d;
}

function nextDay(date: Date, weekday: WeekdayIndex): Date {
  const d = new Date(date);
  let add = (7 + weekday - d.getDay()) % 7;
  if (add === 0) add = 7;
  d.setDate(d.getDate() + add);
  return d;
}

function differenceInCalendarDays(a: Date, b: Date): number {
  const msPerDay = 24 * 60 * 60 * 1000;
  const start = new Date(Date.UTC(a.getFullYear(), a.getMonth(), a.getDate()));
  const end = new Date(Date.UTC(b.getFullYear(), b.getMonth(), b.getDate()));
  return Math.round((start.getTime() - end.getTime()) / msPerDay);
}

function eachDayOfInterval({ start, end }: { start: Date; end: Date }): Array<Date> {
  const days: Array<Date> = [];
  const cur = new Date(start);
  while (cur <= end) {
    days.push(new Date(cur));
    cur.setDate(cur.getDate() + 1);
  }
  return days;
}

interface Props {
  username: string;
  year?: number | 'last';
  repo?: string;
}

function range(n: number) {
  return [...Array(n).keys()];
}

import { getSecret } from 'astro:env/server';

async function fetchWithTimeout(
  input: RequestInfo | URL,
  init?: RequestInit & { timeoutMs?: number },
): Promise<Response> {
  const { timeoutMs = 5000, ...rest } = init || {};
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeoutMs);
  try {
    return await fetch(input, { ...rest, signal: controller.signal });
  } finally {
    clearTimeout(id);
  }
}

async function fetchData(
  username: string,
  year: number | 'last',
  repo?: string,
): Promise<GitHubActivityApiResponse> {
  const token = getSecret('GITHUB_TOKEN') || import.meta.env.GITHUB_TOKEN;
  if (token) {
    const now = new Date();
    let from: Date;
    let to: Date;
    if (year === 'last') {
      to = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      from = subWeeks(to, 52);
    } else {
      from = new Date(year, 0, 1);
      to = new Date(year, 11, 31, 23, 59, 59);
    }

    if (repo) {
      const [owner, name] = repo.split('/');
      if (!owner || !name) {
        throw new Error(`Invalid repo format: ${repo}. Expected "owner/repo"`);
      }

      const query = `
        query($owner: String!, $name: String!, $since: GitTimestamp, $until: GitTimestamp) {
          repository(owner: $owner, name: $name) {
            defaultBranchRef {
              target {
                ... on Commit {
                  history(first: 100, since: $since, until: $until) {
                    edges {
                      node {
                        committedDate
                        author {
                          user {
                            login
                          }
                        }
                      }
                    }
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                  }
                }
              }
            }
          }
        }
      `;

      const commitsByDate = new Map<string, number>();
      let hasNextPage = true;
      let endCursor: string | null = null;

      while (hasNextPage) {
        const res = await fetchWithTimeout('https://api.github.com/graphql', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Accept: 'application/vnd.github+json',
            'User-Agent': 'iDiMi-GitHubActivityCalendar',
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({
            query,
            variables: {
              owner,
              name,
              since: from.toISOString(),
              until: to.toISOString(),
            },
          }),
          timeoutMs: 6000,
        });

        const out = await res.json();
        if (!res.ok || out.errors) {
          const msg = out?.errors?.[0]?.message || 'GraphQL error';
          throw new Error(`GitHub GraphQL failed: ${msg}`);
        }

        const history = out?.data?.repository?.defaultBranchRef?.target?.history;
        if (!history) {
          break;
        }

        for (const edge of history.edges as Array<any>) {
          const commitDate = edge.node.committedDate;
          const authorLogin = edge.node.author?.user?.login;

          if (authorLogin === username) {
            const date = String(commitDate).slice(0, 10);
            commitsByDate.set(date, (commitsByDate.get(date) || 0) + 1);
          }
        }

        hasNextPage = history.pageInfo.hasNextPage;
        endCursor = history.pageInfo.endCursor;

        if (!hasNextPage) break;
      }

      const days: Array<GitHubActivityDay> = [];
      const allDays = eachDayOfInterval({ start: from, end: to });

      for (const day of allDays) {
        const date = formatISO(day);
        const count = commitsByDate.get(date) || 0;
        let level = 0;
        if (count > 0) level = 1;
        if (count >= 3) level = 2;
        if (count >= 6) level = 3;
        if (count >= 10) level = 4;

        days.push({ date, count, level });
      }

      return {
        contributions: days,
        total: {
          lastYear: days.reduce((s, a) => s + a.count, 0),
        } as any,
      };
    }

    const query = `
      query($login: String!, $from: DateTime!, $to: DateTime!) {
        user(login: $login) {
          contributionsCollection(from: $from, to: $to) {
            contributionCalendar {
              totalContributions
              colors
              weeks {
                firstDay
                contributionDays {
                  date
                  contributionCount
                  color
                }
              }
            }
          }
        }
      }
    `;
    const res = await fetchWithTimeout('https://api.github.com/graphql', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/vnd.github+json',
        'User-Agent': 'iDiMi-GitHubActivityCalendar',
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        query,
        variables: { login: username, from: from.toISOString(), to: to.toISOString() },
      }),
      timeoutMs: 6000,
    });
    const out = await res.json();
    if (!res.ok || out.errors) {
      const msg = out?.errors?.[0]?.message || 'GraphQL error';
      throw new Error(`GitHub GraphQL failed: ${msg}`);
    }
    const cal = out?.data?.user?.contributionsCollection?.contributionCalendar;
    if (!cal) {
      throw new Error('Unexpected GraphQL response: missing contributionCalendar');
    }
    const colors: Array<string> = Array.isArray(cal.colors) ? cal.colors : [];
    const colorIndex = (c?: string): number => {
      if (!c) return 0;
      const i = colors.indexOf(c);
      return i >= 0 ? i : 0;
    };
    const days: Array<GitHubActivityDay> = [];
    for (const w of cal.weeks as Array<any>) {
      for (const d of w.contributionDays as Array<any>) {
        const date = String(d.date).slice(0, 10);
        const count = Number(d.contributionCount || 0);
        const color = String(d.color || '');
        days.push({ date, count, level: colorIndex(color), color });
      }
    }
    days.sort((a, b) => (a.date < b.date ? -1 : a.date > b.date ? 1 : 0));
    if (days.length === 0) {
      throw new Error('No contributions returned by GitHub');
    }
    return {
      contributions: days,
      total: {
        lastYear: days.reduce((s, a) => s + a.count, 0),
      } as any,
    };
  }

  function validateActivities(activities: Array<GitHubActivityDay>) {
    if (activities.length === 0) {
      throw new Error('Activity data must not be empty.');
    }
    for (const { date, count } of activities) {
      if (!isValid(parseISO(date))) {
        throw new Error(`Activity date '${date}' is not a valid ISO 8601 date string.`);
      }
      if (count < 0) {
        throw new RangeError(`Activity count must not be negative, found ${count}.`);
      }
    }
  }
  const apiUrl = 'https://github-contributions-api.jogruber.de/v4/';
  const response = await fetchWithTimeout(`${apiUrl}${username}?y=${String(year)}`, {
    timeoutMs: 6000,
  });
  const data = (await response.json()) as GitHubActivityApiResponse;
  if (!response.ok) {
    const message = data.error || 'Unknown error';
    throw Error(`Fetching GitHub contribution data for "${username}" failed: ${message}`);
  }

  validateActivities(data.contributions);

  return data;
}

function calcColorScale(): Array<string> {
  return ['#ebedf0', '#9be9a8', '#40c463', '#30a14e', '#216e39'];
}

function fillHoles(activities: Array<GitHubActivityDay>): Array<GitHubActivityDay> {
  const calendar = new Map<string, GitHubActivityDay>(activities.map((a) => [a.date, a]));
  const firstActivity = activities[0] as GitHubActivityDay;
  const lastActivity = activities[activities.length - 1] as GitHubActivityDay;

  return eachDayOfInterval({
    start: parseISO(firstActivity.date),
    end: parseISO(lastActivity.date),
  }).map((day) => {
    const date = formatISO(day);
    if (calendar.has(date)) {
      return calendar.get(date) as GitHubActivityDay;
    }
    return {
      date,
      count: 0,
      level: 0,
    };
  });
}

function groupByWeeks(
  activities: Array<GitHubActivityDay>,
  weekStart: WeekdayIndex = 0,
): Array<GitHubActivityWeek> {
  const normalizedActivities = fillHoles(activities);
  const firstActivity = normalizedActivities[0] as GitHubActivityDay;
  const firstDate = parseISO(firstActivity.date);
  const firstCalendarDate =
    getDay(firstDate) === weekStart ? firstDate : subWeeks(nextDay(firstDate, weekStart), 1);
  const paddedActivities = [
    ...(Array(differenceInCalendarDays(firstDate, firstCalendarDate)).fill(
      undefined,
    ) as Array<GitHubActivityDay>),
    ...normalizedActivities,
  ];
  const numberOfWeeks = Math.ceil(paddedActivities.length / 7);

  return [...Array(numberOfWeeks).keys()].map((weekIndex) =>
    paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7),
  );
}

function getMonthLabels(
  weeks: Array<GitHubActivityWeek>,
  monthNames: Array<string>,
): Array<GitHubActivityMonthLabel> {
  return weeks
    .reduce<Array<GitHubActivityMonthLabel>>((labels, week, weekIndex) => {
      const firstActivity = week.find((activity) => activity !== undefined);
      if (!firstActivity) {
        throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty.`);
      }
      const month = monthNames[getMonth(parseISO(firstActivity.date))];
      if (!month) {
        const monthName = new Date(firstActivity.date).toLocaleString('en-US', {
          month: 'short',
        });
        throw new Error(`Unexpected error: undefined month label for ${monthName}.`);
      }
      const prevLabel = labels[labels.length - 1];
      if (weekIndex === 0 || !prevLabel || prevLabel.label !== month) {
        return [...labels, { weekIndex, label: month }];
      }
      return labels;
    }, [])
    .filter(({ weekIndex }, index, labels) => {
      const minWeeks = 3;
      if (index === 0) {
        return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;
      }
      if (index === labels.length - 1) {
        return weeks.slice(weekIndex).length >= minWeeks;
      }
      return true;
    });
}

const { username, year = 'last', repo } = Astro.props;

function makeEmptyLastYear(): GitHubActivityApiResponse {
  const today = new Date();
  const start = subWeeks(today, 52);
  const days = eachDayOfInterval({ start, end: today }).map((d) => ({
    date: formatISO(d),
    count: 0,
    level: 0,
  }));
  return {
    contributions: days,
    total: { lastYear: 0 } as any,
  };
}

let data: GitHubActivityApiResponse;
try {
  data = await fetchData(username, year, repo);
} catch (err) {
  console.warn('[GitHubActivityCalendar] fetch failed, using fallback:', err);
  data = makeEmptyLastYear();
}

const maxLevel = 4;
const blockMargin = 4;
const labelMargin = 8;
const blockRadius = 2;
const blockSize = 12;
const fontSize = 14;
const hideColorLegend = false;
const hideMonthLabels = false;
const hideTotalCount = false;
const weekStart = 0;

const colorScale = calcColorScale();
const activities = data.contributions;
const totalCount = activities.reduce((s, a) => s + a.count, 0);
const legendColors = range(5).map((i) => {
  const found = activities.find((a) => a.level === i && a.color);
  return (found && found.color) || colorScale[i];
});

const firstActivity = activities[0];
const activityYear = getYear(parseISO(firstActivity.date));
const weeks = groupByWeeks(activities, weekStart);
const labels = {
  months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  totalCount: `{{count}} contributions in ${year === 'last' ? 'the last year' : '{{year}}'}`,
  legend: {
    less: 'Less',
    more: 'More',
  },
};
const labelHeight = hideMonthLabels ? 0 : fontSize + labelMargin;
const width = weeks.length * (blockSize + blockMargin) - blockMargin;
const height = labelHeight + (blockSize + blockMargin) * 7 - blockMargin;
---

<article id="github-activity-calendar" class="flex w-full flex-col gap-2 text-sm">
  <div
    class="w-full overflow-x-auto pt-0.5"
    style={{
      scrollbarGutter: 'stable',
    }}
  >
    <svg
      class="visible block w-full"
      width={width}
      height={height}
      viewBox={`0 0 ${width} ${height}`}
      style={`min-width: ${width}px;`}
      preserveAspectRatio="xMinYMin meet"
    >
      {
        !hideMonthLabels && (
          <g>
            {getMonthLabels(weeks, labels.months).map(({ label, weekIndex }) => (
              <text
                x={(blockSize + blockMargin) * weekIndex}
                y={0}
                dominant-baseline="hanging"
                fill="currentColor"
              >
                {label}
              </text>
            ))}
          </g>
        )
      }
      {
        weeks.map((week, weekIndex) => (
          <g transform={`translate(${(blockSize + blockMargin) * weekIndex}, 0)`}>
            {week.map((activity, dayIndex) => {
              if (!activity) return null;
              return (
                <rect
                  class="stroke-black/10 dark:stroke-white/10"
                  x={0}
                  y={labelHeight + (blockSize + blockMargin) * dayIndex}
                  width={blockSize}
                  height={blockSize}
                  rx={blockRadius}
                  ry={blockRadius}
                  fill={activity.color || colorScale[activity.level]}
                  data-date={activity.date}
                  data-level={activity.level}
                />
              );
            })}
          </g>
        ))
      }
    </svg>
  </div>
  {
    !(hideTotalCount && hideColorLegend) && (
      <footer class="flex flex-col gap-x-1 gap-y-2 sm:flex-row sm:justify-between">
        {!hideTotalCount && (
          <div>
            {labels.totalCount
              ? labels.totalCount
                  .replace('{{count}}', String(totalCount))
                  .replace('{{year}}', String(activityYear))
              : `${totalCount} activities in ${activityYear}`}
          </div>
        )}
        {!hideColorLegend && (
          <div class="flex items-center gap-[3px]">
            <span class="mr-1.5">{labels.legend.less}</span>
            {range(maxLevel + 1).map((level) => (
              <svg width={blockSize} height={blockSize}>
                <rect
                  class="stroke-black/10 dark:stroke-white/10"
                  width={blockSize}
                  height={blockSize}
                  fill={legendColors[level]}
                  rx={blockRadius}
                  ry={blockRadius}
                />
              </svg>
            ))}
            <span class="ml-1.5">{labels.legend.more}</span>
          </div>
        )}
      </footer>
    )
  }
</article>
